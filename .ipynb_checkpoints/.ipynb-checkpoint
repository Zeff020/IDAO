{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Using TensorFlow backend.\n"
     ]
    }
   ],
   "source": [
    "import tensorflow as tf\n",
    "import keras\n",
    "from keras import backend as K\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.model_selection import train_test_split\n",
    "import pandas as pd\n",
    "import utils\n",
    "import scoring\n",
    "import numpy as np\n",
    "\n",
    "from skopt import Optimizer\n",
    "\n",
    "from skopt.learning import GaussianProcessRegressor\n",
    "from skopt.learning.gaussian_process.kernels import Matern, RBF, WhiteKernel\n",
    "\n",
    "from skopt.learning import RandomForestRegressor\n",
    "\n",
    "from skopt.acquisition import gaussian_ei as acq_func\n",
    "\n",
    "from IPython import display"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "### Importing and structuring data ###\n",
    "\n",
    "DATA_PATH = \"./data/\"\n",
    "train, test = utils.load_small_data_csv(DATA_PATH,\"train_smaller100.csv.gz\" , \"test_smaller100.csv.gz\", utils.SIMPLE_FEATURE_COLUMNS)\n",
    "\n",
    "PointResiduals,Angles = utils.kink(train)\n",
    "train['PointResiduals'] = pd.Series(PointResiduals, index=train.index)\n",
    "train['Angles'] = pd.Series(PointResiduals, index=train.index)\n",
    "\n",
    "\n",
    "train_part, val_part = train_test_split(train, test_size=0.20, shuffle=True)\n",
    "x_train = train_part.loc[:, utils.SIMPLE_FEATURE_COLUMNS].values\n",
    "x_val   =  val_part.loc[:, utils.SIMPLE_FEATURE_COLUMNS].values\n",
    "y_train = train_part.loc[:, [\"label\"]].values\n",
    "y_val = val_part.loc[:, [\"label\"]].values\n",
    "#y_train_weight = train_part.loc[:, [\"weight\"]].values\n",
    "\n",
    "# turn labels into categorical classes\n",
    "classes = [0,1]\n",
    "y_train = keras.utils.to_categorical(y_train, num_classes=len(classes))\n",
    "y_val   = keras.utils.to_categorical(y_val,   num_classes=len(classes))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "### Defining utils ###\n",
    "\n",
    "# Rectified linear unit\n",
    "\n",
    "def relu(x):\n",
    "  return np.array([ (i>0) * abs(i) for i in x ])\n",
    "\n",
    "# plotting the bayesian optimizer\n",
    "\n",
    "def plot_bo(bo, suggestion=None, value=None):\n",
    "    a, b = bo.space.bounds[0]\n",
    "    \n",
    "    # getting the latest model\n",
    "    model = bo.models[-1]\n",
    "    \n",
    "    xs = np.linspace(a, b, num=100)\n",
    "    x_model = bo.space.transform(xs.reshape(-1, 1).tolist())\n",
    "    \n",
    "    mean, std = model.predict(x_model, return_std=True)\n",
    "    \n",
    "    plt.subplots(nrows=1, ncols=2, figsize=(12, 4))\n",
    "    \n",
    "    plt.subplot(1, 2, 1)\n",
    "    plt.scatter(\n",
    "        np.array(bo.Xi)[:, 0],\n",
    "        np.array(bo.yi),\n",
    "        color='red',\n",
    "        label='observations'\n",
    "    )\n",
    "    if suggestion is not None:\n",
    "        plt.scatter([suggestion], value, color='blue', label='suggestion')\n",
    "    \n",
    "    plt.plot(xs, mean, color='green', label='model')\n",
    "    plt.fill_between(xs, mean - 1.96 * std, mean + 1.96 * std, alpha=0.1, color='green')\n",
    "    plt.legend()\n",
    "    \n",
    "    plt.subplot(1, 2, 2)\n",
    "    acq = acq_func(x_model, model, np.min(bo.yi))\n",
    "    plt.plot(xs, acq, label='Expected Improvement')\n",
    "    plt.legend()\n",
    "    \n",
    "    plt.show()\n",
    "\n",
    "# \n",
    "\n",
    "def cum_min(xs):\n",
    "    result = np.zeros_like(xs)\n",
    "    cmin = xs[0]\n",
    "    \n",
    "    result[0] = xs[0]\n",
    "    \n",
    "    for i in range(1, xs.shape[0]):\n",
    "        if cmin > xs[i]:\n",
    "            cmin = xs[i]\n",
    "\n",
    "        result[i] = cmin\n",
    "    \n",
    "    return result\n",
    "\n",
    "# plots progress of BO over time\n",
    "\n",
    "def plot_convergence(bo):\n",
    "    display.clear_output(wait=True)\n",
    "    values = np.array(bo.yi)\n",
    "    \n",
    "    plt.figure(figsize=(12, 6))\n",
    "    plt.plot(cum_min(values), label='minimal discovered')\n",
    "    plt.scatter(np.arange(len(bo.yi)), bo.yi, label='observations')\n",
    "    plt.xlabel('step', fontsize=14)\n",
    "    plt.ylabel('loss', fontsize=14)\n",
    "    \n",
    "    plt.legend(loc='upper right', fontsize=18)\n",
    "    \n",
    "    plt.show()\n",
    "\n",
    "# Prints best parameters\n",
    "    \n",
    "def print_best(bo):\n",
    "    best_result_index = np.argmin(bo.yi)\n",
    "    best_parameters = bo.Xi[best_result_index]\n",
    "\n",
    "    NodesInFirstDense, NodesInSecondDense, DropoutValue, INIT_LEARNINGRATE = best_parameters\n",
    "    \n",
    "    print(\n",
    "        'Best model:\\n Nodes in first dense layer= {0} \\n Nodes in second dense layer= {1} \\n learning rate= {2} \\n Dropout value= {3}'.format(\n",
    "            int(np.ceil(NodesInFirstDense)),\n",
    "            int(np.ceil(NodesInSecondDense)),\n",
    "            INIT_LEARNINGRATE,\n",
    "            DropoutValue\n",
    "        )\n",
    "    )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "### Target function with as input optimizeable parameters ###\n",
    "\n",
    "def target_function(params, X_train=x_train, y_train=y_train, X_score=x_val, y_score=y_val):\n",
    "    \n",
    "    # Optimized parameters\n",
    "    NodesInFirstDense, NodesInSecondDense, DropoutValue, INIT_LEARNINGRATE = params\n",
    "    \n",
    "    # Making sure that the number of nodes are integers\n",
    "    NodesInFirstDense = int(np.ceil(NodesInFirstDense))\n",
    "    NodesInSecondDense = int(np.ceil(NodesInSecondDense))\n",
    "    \n",
    "    # Two parameters not optimized in this case, but can be optimized if needed\n",
    "    BATCH_SIZE = 16  # should be a factor of len(x_train) and len(x_val) etc.\n",
    "    EPOCHS = 3\n",
    "\n",
    "    assert len(y_train) == len(x_train), \"x_train and y_train not same length!\"\n",
    "    #assert len(y_train) % BATCH_SIZE == 0, \"batch size should be multiple of training size,{0}/{1}\".format(len(y_train),BATCH_SIZE)\n",
    "\n",
    "    from keras.models import Sequential\n",
    "    from keras.layers import Dense, Activation, Dropout\n",
    "    from keras.layers.normalization import BatchNormalization\n",
    "\n",
    "    K.clear_session()\n",
    "\n",
    "    model = Sequential()\n",
    "    model.add(Dense(NodesInFirstDense, activation='relu', input_shape=( len( utils.SIMPLE_FEATURE_COLUMNS ), ))) #length = input vars\n",
    "    model.add(BatchNormalization())\n",
    "    model.add(Dropout(DropoutValue))\n",
    "    model.add(Dense(NodesInSecondDense , activation='relu'))\n",
    "    model.add(Dense( len(classes) )) # muon and 'other'\n",
    "    model.add(Activation(\"softmax\")) # output probabilities\n",
    "\n",
    "    model.compile(\n",
    "        loss=\"categorical_crossentropy\",\n",
    "        optimizer=keras.optimizers.adamax(lr=INIT_LEARNINGRATE),\n",
    "        metrics=['accuracy'] \n",
    "        )\n",
    "\n",
    "\n",
    "    model.fit(\n",
    "        x_train, y_train,\n",
    "        batch_size = BATCH_SIZE,\n",
    "        epochs = EPOCHS,\n",
    "        validation_data = (x_val, y_val),\n",
    "        shuffle = True\n",
    "        )\n",
    "\n",
    "    #model.save_model(\"keras_basic_model.xgb\")\n",
    "\n",
    "\n",
    "    # score\n",
    "\n",
    "    validation_predictions = model.predict_proba(val_part.loc[:, utils.SIMPLE_FEATURE_COLUMNS].values)[:, 1]\n",
    "    result = scoring.rejection90(val_part.label.values, validation_predictions, sample_weight=val_part.weight.values)\n",
    "    print(result)\n",
    "    \n",
    "    return 1 - result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "### Setting dimensions for optimizeable parameters ###\n",
    "\n",
    "dimensions_4 =[\n",
    "    # NodesInFirstDense\n",
    "    (4.0, 300.0),\n",
    "    \n",
    "    # NodesInSecondDense\n",
    "    (4.0, 300.0),\n",
    "    \n",
    "    # LOG_INIT_LEARNINGRATE\n",
    "    (1.0e-4, 1.0e-2),\n",
    "    \n",
    "    # DropoutValue\n",
    "    (0.0, 0.1)\n",
    "]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "### Random forest regressor optimizer ###\n",
    "\n",
    "bo_rf_4 = Optimizer(\n",
    "    dimensions=dimensions_4,\n",
    "    base_estimator=RandomForestRegressor(\n",
    "        n_estimators=100, n_jobs=4, min_variance=1.0e-6\n",
    "    ),\n",
    "    n_initial_points=5,\n",
    "    acq_func='EI',   \n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "### Gaussian optimizer ###\n",
    "\n",
    "bo_gp_1 = Optimizer(\n",
    "    ### telling optimizer boundaries for each parameter\n",
    "    dimensions=dimensions_1,\n",
    "    \n",
    "    ### setting regressor\n",
    "    base_estimator=GaussianProcessRegressor(\n",
    "        kernel=RBF(length_scale_bounds=[1.0e-6, 1.0e+6]) + \\\n",
    "            WhiteKernel(noise_level=1.0e-5, noise_level_bounds=[1.0e-6, 1.0e-2]),\n",
    "    ),\n",
    "    n_initial_points=2,\n",
    "    acq_func='EI',   \n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "data": {
      "image/png": "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WbNGknTzzTcrLy+vzr+DDjpIO3fu1FdffVUnzlj2bbx5OZzgk6puue5kZhtVPVJJS0lyzt0v6SVVDyW4TtXDCV4UmPatmf1a0orAqqY755q6SRMpKNwQX9EOAYaGkr0P/bj9WEf4iPU9JXqfJOI9+53fjrMWGab8DjkNRou4+bSGSU0Nv49qUlNef3ttWlWnFJmZmSHnb9mienpzR9CoWW/w9msckN0iovXVjy1cuaTaXwuccxo5cqTWrFmjq6++Wn2PLNS+Ftnapwy98MwT+tv8Z9S2VfRpVc36zRrWjiL9deOYY47Rxx9/rEWLFmnp0qVaunSpnnjiCd12221avny5OnbsWGc7jX2GHVpnRT2U4/nnn6/rr79e8+bN08iRI/Wvf/1L69evb9A/3jmngQMH6q677tKGb3bWdk0K1qlTXp1fWroc2L7B51oT33XXXafRo0OPtVFTaYrHvo03zxJv59x5YaY7SZMamfagpAcTERf8I1w/ymj6WSK0ZO/DdNx+rOtM9D5J9j5PhmS/5+Dtr1mzJuoEs0PrrCaXaWx6c5Zpruasr31OSx3ZLbpuGOG2n72nnSSF/WUnHt59912tWrVKN910k2699dY605Y8/1Sz13vooYdK+r4lN1iossYccMABOuuss3TWWWdJku69915NmjRJDzzwgCZPnqyCgupffUpKSnTyySc3+hnWxPP+++/X/l1j9erVkur+ctCpUyedcsopmj9/vnbs2KF58+YpIyOjQb/9Pn36aPPmzRoxYoS27a6s7eNdI8O+r6R+mRfo2hOiItOnT3V/78zMTJ100klN7pN47dt48lNXEwAAAF+qaRWv31L6n//8R/Pnz2/2egcNGqRu3brpoYce0pYtW2rLt2/frvvvvz+idQQvV6NmmL9vv63uJDBy5Eh16tRJ//d//6cvvviiwfw17+v000+XmWnWrFl1Rgf54osv9NBDD6lnz54qLCyss+z48eO1a9cuPfbYY3rmmWd08sknq2vXrnXmufDCC/Xll1/qrrvuUofWWcrvkFPbup2VmaGWFdsjqswVFhZqwIABuv/+++t0ealRWVlZ+54POuggDR06VM8//7w+/PDD2nkqKip09913h91WIvjp5koAAABf6tu3r/r3768777xTu3btUkFBgT788EP96U9/0oABA/T22283a72ZmZm6++67dc4552jw4MG69NJL1aJFCz344IM68MADtWHDhohiGzp0qIYMGaKuXbvqiy++0Jw5c5SVlaVx48ZJklq3bq0HHnhAZ599tgYMGKBLLrlEhx12mDZv3qxFixbpV7/6lc444wwVFBRo8uTJuvPOOzV8+HCde+65+u677zRnzhzt2LFDjz/+eIOuOT/5yU904IEHasqUKdq+fXudmyprXHPNNVq8eLEmT56sJUuWaMSIEWrXrp02bNigV199VdnZ2Vq6dGnY92pmevTRRzVixAgdeeSRuvjii9W/f3/t2rVL69at03PPPacZM2bUjmpy11136YQTTtCwYcM0adIk5ebm6qmnnlJlZWUEn078kXgDAACEkZmZqRdffFHXX3+9HnnkEe3cuVMDBgzQI488olWrVjU78Zaks88+W88++6ymT5+uW265RQcddJAmTJig4cOHa+TIkWGXv+666/TSSy/p97//vbZt21bb0jtt2jT94Ac/qJ3v9NNP1/Lly3X77bfrgQce0HfffafOnTvruOOO08CBA2vnu+OOO3TYYYfp3nvv1dSpU5WVlaUhQ4boiSee0A9/+MMG28/KytJ5552nP/7xj2rXrp3GjBnTYJ6WLVvqxRdf1L333qtHH31UN998s6Tqm2YHDx4cMllvzFFHHaWSkhLNmDFDCxcu1P3336+2bduqV69emjBhgn70o++HljzmmGO0ePFiTZ06VTNnzlS7du3005/+VFdccUWd9+wVS1bn8kQrKipyxcXFyQ4DALAfW7Nmjfr27ZvsMADEIJLvsZmtdM4VhVsXfbwBAAAAD5B4AwAAAB6gjzcAAECKCzf+O/yBxBsAACCFbd1VUWdc7IqqfSrdWi6p6fHd4T26mgAAAKSwr7btrvMwGkna51ydp3vCH0i8AQAAUlhF1b6oypE8JN4AAAAprOYJkJGWI3n4RAAAAFJY5/bZyjCrU5Zhps7ts5MUERrDzZUAAAAprOYGSkY18T8SbwAAgBTXoXUWiXYKoKsJAAAA4AESbwAAAMADJN4AAMBTDz/8sMxMy5YtS3YovmFmmjBhQrLDQIKReAMAACRYWVmZbrnlFiob+zlurgQAAEiwsrIy3XrrrZKkE044ocH08vJyZWZmehwVvEaLNwAA2O9VVVVp165dSdt+dna2WrZsmbTtwxsk3gAAIC62bNmiSZMmqXv37srKylL37t01adIkffPNNyHnr6ys1C233KKePXuqVatWOvLII/XUU081mO/f//63fvzjH+vggw9Wdna28vPzdcopp+iNN96oM9+2bds0ZcoUHXbYYWrVqpXy8vJ03nnnaf369XXmq+lj/ve//12//vWvdeihhyo7O1tPP/20hgwZos6dO6uysrJBHIsWLZKZ6Xe/+50kad++ffrNb36j4cOH6+CDD1ZWVpZ69OihK664os57XrZsmXr37i1JuvXWW2VmMjP16tWrdp7G+njPnTtXRx99tHJyctS+fXuNHDlSy5cvbzBfzfKvv/66jj/+eLVp00adOnXSJZdcoh07dtSZ9/PPP9fFF19cu98POuggHXvssXrkkUcarBfxRVcTAAAQs23btunYY4/VunXrdPHFF+voo49WSUmJ7rvvPi1ZskRvvfWW2rZtW2eZKVOmaOfOnbriiitkZnrooYd03nnnaffu3bVJ6Nq1a3XyySfr4IMP1jXXXKPOnTvryy+/1GuvvaZVq1Zp6NChdba/YcMGXXzxxerfv7+++OIL3XvvvRoyZIiKi4vVs2fPOtu//vrrtXfvXl166aVq166dCgoKNH78eE2aNEkvv/yyTj311Drzz5s3Ty1atND5558vSaqoqNCsWbN01lln6YwzzlCbNm20YsUKPfDAA1q+fLlWrlyprKws9e3bV3fffbeuvfZanXnmmRo7dqwk6YADDmhyn06ZMkV33nmnBg8erNtvv13fffed5syZoxNPPFHPP/+8TjnllDrzv/POOzr11FN10UUX6fzzz9eyZcv0wAMPKCMjQ3PmzJFUXdk5+eSTVVpaqiuvvFKHH364tm3bpnfffVf/+te/NH78+Cg+dUTNOZeW/wYNGuQAAEim1atXJ2zd89/e6I6d8arrNeVv7tgZr7r5b29M2LYi8d///d9Okps9e3ad8j/+8Y9Okrvxxhtryx566CEnyfXo0cOVlZXVlpeVlbkePXq4Dh06uF27djnnnLvnnnucJPfmm282uf2rr77aZWdnu3feeadO+aeffuratm3rxo8f32D7hx9+uNu5c2ed+b/55huXlZXlfvrTn9Yp3759u2vdurU77bTTasv27dtXG2ewuXPnOknuL3/5S23ZJ5984iS5m2++OWT8kurE+MEHHzgzc8OGDXN79uypLS8tLXXt27d3PXv2dJWVlXWWNzP3+uuv11nvKaec4lq0aOG+++4755xzq1atcpLcHXfcETIONBTJ91hSsYsgP6WrCQAAKWZBSammPfeeSsvK5SSVlpVr2nPvaUFJadJimj9/vvLy8jRx4sQ65Zdddpk6deqk+fPnN1jmiiuuUPv27Wtft2/fXpdffrm2bt1aO/pHzfTnn39eu3fvDrlt55wef/xxDR8+XPn5+dqyZUvtvzZt2mjo0KF65ZVXQm6/devWdco6duyo0047TQsXLlRZWVlt+bPPPqtdu3bVaRE2M+Xk5Eiq7iNeVlamLVu2aMSIEZKkN998s9H9Fc7zzz8v55xuuOEGZWV9/0TKrl27asKECfrss89UUlJSZ5ljjjmm9heAGiNGjFBlZaU+/fRTSd/vz6VLl+rrr79udnxoHhJvAABSzKxFa1W+t6pOWfneKs1atDZJEUmffPKJCgoK1KJF3V6sLVq0UEFBQYN+1pLUt2/fBmX9+vWTpNr5x40bp5NOOkm33367OnbsqBEjRuiOO+7QZ599VrvM5s2b9c033+iVV15RXl5eg3+LFy/WV1991WBbhx9+eMj3cuGFF2rPnj16+umna8vmzZunDh06NOh+UtMvPCcnRx06dFBeXp4OOeQQSdLWrVtDrj8Sn3zyiSSpf//+DaYNGDBAkhrs05rtBjvwwAMlqbbPec+ePfU///M/euWVV9SlSxcNGjRIN9xwg1asWNHsWBE5Em8AAFLMprLyqMr9yswalFX/av+9Vq1aafHixXrzzTc1bdo0ZWZm6qabbtIRRxxR24pes8xJJ52kxYsXh/y3aNGiBtuq39pd45RTTlFeXp7mzZsnSdqwYYP+8Y9/aNy4cWrVqlXtfM8995zOPfdcSdI999yjF154QYsXL9bLL78sqfrmy+aqvx8i0dRwhMHru+222/TRRx/pd7/7nQ499FDNnTtXgwcP1pQpU5oVKyLHzZUAAKSYrrk5Kg2RZHfNzUlCNNUOOeQQrV27VpWVlXVavSsrK/Xhhx+GbI1dvXq1Tj/99Dpla9asqV1fsMGDB2vw4MGSqkflKCws1I033qgzzzxTeXl5ys3N1fbt23XSSSfF/F5qbqC85557tH79ej355JNyzjW48fDRRx9Vdna2li5dWieJ/+CDDxqsM1QloymHHnqoJOn999+v/bvG6tWrJYVu4Y7UIYccoquuukpXXXWVdu/erVGjRunOO+/Uddddp4MOOqjZ60XTaPEGACDFTB5VoJyWdVs3c1pmavKogiRFJI0ZM0abN2/W3Llz65T/+c9/1ubNm3XmmWc2WOa+++7Ttm3bal9v27ZN999/v3Jzc3X88cdLqh6isL5u3bopLy9P3377rSQpIyNDF1xwgd566y09++yzIeOLtj9zTZI9b948PfrooyooKNCQIUPqzJOZmSkzq9Oy7ZzTbbfd1mB9NSOY1MQczumnny4z06xZs7R3797a8i+++EIPPfSQevbsqcLCwqjek1S9j4PXJ1WPIV7T7SeW7jEIjxZvAABSzJjCfEnVfb03lZWra26OJo8qqC1PhhtuuEHPPPOMJk2apLfffluFhYUqKSnRAw88oIKCAt1www0NlunUqZOGDBmiiy++WM45PfTQQ9qwYYPmzp1b24J822236ZVXXtGpp56q3r17yzmnF154QR988EGddf7mN7/Ra6+9pnPOOUfnnHOOhg4dqqysLH322Wd66aWXNGjQID388MMRv5/CwkINHDhQd999t7Zv367bb7+9wTxnn322/vrXv2rEiBG68MILtXfvXi1YsCDkg3gOPPBAHXbYYXrqqad06KGHqnPnzmrTpo1OO+20kNsvKCjQ5MmTdeedd2r48OE699xza4cT3LFjhx5//PFmPely6dKlmjhxos466ywVFBTogAMO0MqVKzV37lwNGTJEBQXJq7ztFyIZ+iQV/zGcIAAg2RI5nKAfff311+6KK65w+fn5rkWLFi4/P99deeWVbvPmzXXmqxnOb/Hixe6mm25y3bt3d1lZWa5///7u8ccfrzPv0qVL3TnnnON69uzpsrOzXYcOHdzgwYPdn//8Z7dv37468+7cudNNnz7dDRgwwGVnZ7sDDjjAHXHEEe6SSy5xb7zxRoPtL126tMn389vf/tZJchkZGW7Dhg0h55kzZ47r27eva9WqlTv44IPdpZde6r755psGwwM659ybb77pjj32WNe6dWsnyfXs2bN2Wqj5a9Z/1FFHuVatWrm2bdu6k046yf3zn/9sMF9jy9d/r+vXr3eXXXaZO+KII1zbtm1d69at3RFHHOH+93//t87QjvhePIcTNNeMzvupoKioyBUXFyc7DADAfmzNmjUhR+4AkDoi+R6b2UrnXFG4ddHHGwAAAPAAiTcAAADgAU8TbzMbbWZrzWyd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\n",
      "text/plain": [
       "<Figure size 864x432 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "### Actual optimization process ###\n",
    "\n",
    "Parameter_List = ([])\n",
    "for i in range(150):\n",
    "    x = bo_rf_4.ask()\n",
    "    print(x)\n",
    "    f = target_function(x) # Other inputs are automatically set\n",
    "    \n",
    "    Parameter_List = np.append(Parameter_List, x)\n",
    "    bo_rf_4.tell(x, f)\n",
    "        \n",
    "    plot_convergence(bo_rf_4)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Best model:\n",
      " Nodes in first dense layer= 235 \n",
      " Nodes in second dense layer= 147 \n",
      " learning rate= 0.02177968898175681 \n",
      " Dropout value= 0.005580370632707155\n"
     ]
    }
   ],
   "source": [
    "print_best(bo_rf_4)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense_1 (Dense)              (None, 271)               17886     \n",
      "_________________________________________________________________\n",
      "batch_normalization_1 (Batch (None, 271)               1084      \n",
      "_________________________________________________________________\n",
      "dropout_1 (Dropout)          (None, 271)               0         \n",
      "_________________________________________________________________\n",
      "dense_2 (Dense)              (None, 280)               76160     \n",
      "_________________________________________________________________\n",
      "dense_3 (Dense)              (None, 2)                 562       \n",
      "_________________________________________________________________\n",
      "activation_1 (Activation)    (None, 2)                 0         \n",
      "=================================================================\n",
      "Total params: 95,692\n",
      "Trainable params: 95,150\n",
      "Non-trainable params: 542\n",
      "_________________________________________________________________\n",
      "None\n",
      "Train on 43565 samples, validate on 10892 samples\n",
      "Epoch 1/3\n",
      "43565/43565 [==============================] - 14s 321us/step - loss: 0.2786 - acc: 0.9236 - val_loss: 0.2719 - val_acc: 0.9250\n",
      "Epoch 2/3\n",
      "43565/43565 [==============================] - 12s 265us/step - loss: 0.2433 - acc: 0.9250 - val_loss: 0.2521 - val_acc: 0.9247\n",
      "Epoch 3/3\n",
      "43565/43565 [==============================] - 11s 249us/step - loss: 0.2363 - acc: 0.9251 - val_loss: 0.2567 - val_acc: 0.9266\n",
      "0.3481612531447594\n",
      "Train on 43565 samples, validate on 10892 samples\n",
      "Epoch 1/3\n",
      "43565/43565 [==============================] - 11s 260us/step - loss: 0.2347 - acc: 0.9254 - val_loss: 0.2492 - val_acc: 0.9261\n",
      "Epoch 2/3\n",
      "43565/43565 [==============================] - 12s 266us/step - loss: 0.2334 - acc: 0.9253 - val_loss: 0.2366 - val_acc: 0.9262\n",
      "Epoch 3/3\n",
      "43565/43565 [==============================] - 11s 243us/step - loss: 0.2326 - acc: 0.9258 - val_loss: 0.2347 - val_acc: 0.9266\n",
      "0.3777592072609885\n",
      "Train on 43565 samples, validate on 10892 samples\n",
      "Epoch 1/3\n",
      "43565/43565 [==============================] - 11s 246us/step - loss: 0.2322 - acc: 0.9259 - val_loss: 0.2292 - val_acc: 0.9276\n",
      "Epoch 2/3\n",
      "43565/43565 [==============================] - 12s 278us/step - loss: 0.2303 - acc: 0.9265 - val_loss: 0.2333 - val_acc: 0.9264\n",
      "Epoch 3/3\n",
      "43565/43565 [==============================] - 11s 245us/step - loss: 0.2311 - acc: 0.9263 - val_loss: 0.2338 - val_acc: 0.9273\n",
      "0.3755042846797935\n",
      "Train on 43565 samples, validate on 10892 samples\n",
      "Epoch 1/3\n",
      "43565/43565 [==============================] - 11s 261us/step - loss: 0.2310 - acc: 0.9257 - val_loss: 0.2362 - val_acc: 0.9255\n",
      "Epoch 2/3\n",
      "43565/43565 [==============================] - 12s 268us/step - loss: 0.2297 - acc: 0.9270 - val_loss: 0.2340 - val_acc: 0.9248\n",
      "Epoch 3/3\n",
      "43565/43565 [==============================] - 11s 248us/step - loss: 0.2309 - acc: 0.9260 - val_loss: 0.2338 - val_acc: 0.9249\n",
      "0.4127228370619375\n",
      "Train on 43565 samples, validate on 10892 samples\n",
      "Epoch 1/3\n",
      "43565/43565 [==============================] - 11s 262us/step - loss: 0.2295 - acc: 0.9256 - val_loss: 0.2429 - val_acc: 0.9262\n",
      "Epoch 2/3\n",
      "43565/43565 [==============================] - 11s 253us/step - loss: 0.2300 - acc: 0.9252 - val_loss: 0.2349 - val_acc: 0.9266\n",
      "Epoch 3/3\n",
      "43565/43565 [==============================] - 12s 268us/step - loss: 0.2312 - acc: 0.9258 - val_loss: 0.2394 - val_acc: 0.9265\n",
      "0.3827155505030586\n"
     ]
    }
   ],
   "source": [
    "### Testing the found parameters to see if the results are reproduceable ###\n",
    "\n",
    "INIT_LEARNINGRATE = 0.02532767329545395  \n",
    "BATCH_SIZE = 16  # should be a factor of len(x_train) and len(x_val) etc.\n",
    "EPOCHS = 3\n",
    "\n",
    "assert len(y_train) == len(x_train), \"x_train and y_train not same length!\"\n",
    "#assert len(y_train) % BATCH_SIZE == 0, \"batch size should be multiple of training size,{0}/{1}\".format(len(y_train),BATCH_SIZE)\n",
    "\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense, Activation, Dropout\n",
    "from keras.layers.normalization import BatchNormalization\n",
    "\n",
    "K.clear_session()\n",
    "\n",
    "model = Sequential()\n",
    "model.add(Dense(271, activation='relu', input_shape=( len( utils.SIMPLE_FEATURE_COLUMNS ), ))) #length = input vars\n",
    "model.add(BatchNormalization())\n",
    "model.add(Dropout(0.0009682674694188368))\n",
    "model.add(Dense(280, activation='relu'))\n",
    "model.add(Dense( len(classes) )) # muon and 'other'\n",
    "model.add(Activation(\"softmax\")) # output probabilities\n",
    "\n",
    "print(model.summary())\n",
    "\n",
    "model.compile(\n",
    "    loss=\"categorical_crossentropy\",\n",
    "    optimizer=keras.optimizers.adamax(lr=INIT_LEARNINGRATE),\n",
    "    metrics=['accuracy'] \n",
    "    )\n",
    "\n",
    "# Running test for 5 times in this case\n",
    "for i in range(0,5):\n",
    "    model.fit(\n",
    "        x_train, y_train,\n",
    "        batch_size = BATCH_SIZE,\n",
    "        epochs = EPOCHS,\n",
    "        validation_data = (x_val, y_val),\n",
    "        shuffle = True\n",
    "        )\n",
    "\n",
    "\n",
    "    #model.save_model(\"keras_basic_model.xgb\")\n",
    "\n",
    "\n",
    "    # score\n",
    "\n",
    "    validation_predictions = model.predict_proba(val_part.loc[:, utils.SIMPLE_FEATURE_COLUMNS].values)[:, 1]\n",
    "    result = scoring.rejection90(val_part.label.values, validation_predictions, sample_weight=val_part.weight.values)\n",
    "    print(result)\n",
    "    \n",
    "    i += 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense_1 (Dense)              (None, 100)               6600      \n",
      "_________________________________________________________________\n",
      "batch_normalization_1 (Batch (None, 100)               400       \n",
      "_________________________________________________________________\n",
      "dropout_1 (Dropout)          (None, 100)               0         \n",
      "_________________________________________________________________\n",
      "dense_2 (Dense)              (None, 50)                5050      \n",
      "_________________________________________________________________\n",
      "dense_3 (Dense)              (None, 2)                 102       \n",
      "_________________________________________________________________\n",
      "activation_1 (Activation)    (None, 2)                 0         \n",
      "=================================================================\n",
      "Total params: 12,152\n",
      "Trainable params: 11,952\n",
      "Non-trainable params: 200\n",
      "_________________________________________________________________\n",
      "None\n",
      "Train on 43565 samples, validate on 10892 samples\n",
      "Epoch 1/3\n",
      "43565/43565 [==============================] - 8s 176us/step - loss: 0.2471 - acc: 0.9252 - val_loss: 0.2437 - val_acc: 0.9234\n",
      "Epoch 2/3\n",
      "43565/43565 [==============================] - 6s 143us/step - loss: 0.2357 - acc: 0.9267 - val_loss: 0.2456 - val_acc: 0.9224\n",
      "Epoch 3/3\n",
      "43565/43565 [==============================] - 6s 141us/step - loss: 0.2323 - acc: 0.9263 - val_loss: 0.2408 - val_acc: 0.9236\n",
      "0.3487180061696864\n"
     ]
    }
   ],
   "source": [
    "#### Original keras model for reference ####\n",
    "\n",
    "INIT_LEARNINGRATE = 5e-3\n",
    "BATCH_SIZE = 16  # should be a factor of len(x_train) and len(x_val) etc.\n",
    "EPOCHS = 3\n",
    "\n",
    "assert len(y_train) == len(x_train), \"x_train and y_train not same length!\"\n",
    "#assert len(y_train) % BATCH_SIZE == 0, \"batch size should be multiple of training size,{0}/{1}\".format(len(y_train),BATCH_SIZE)\n",
    "\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense, Activation, Dropout\n",
    "from keras.layers.normalization import BatchNormalization\n",
    "\n",
    "K.clear_session()\n",
    "\n",
    "model = Sequential()\n",
    "model.add(Dense(100, activation='relu', input_shape=( len( utils.SIMPLE_FEATURE_COLUMNS ), ))) #length = input vars\n",
    "model.add(BatchNormalization())\n",
    "model.add(Dropout(0.1))\n",
    "model.add(Dense(50 , activation='relu'))\n",
    "model.add(Dense( len(classes) )) # muon and 'other'\n",
    "model.add(Activation(\"softmax\")) # output probabilities\n",
    "\n",
    "print(model.summary())\n",
    "\n",
    "model.compile(\n",
    "    loss=\"categorical_crossentropy\",\n",
    "    optimizer=keras.optimizers.adamax(lr=INIT_LEARNINGRATE),\n",
    "    metrics=['accuracy'] \n",
    "    )\n",
    "\n",
    "\n",
    "model.fit(\n",
    "    x_train, y_train,\n",
    "    batch_size = BATCH_SIZE,\n",
    "    epochs = EPOCHS,\n",
    "    validation_data = (x_val, y_val),\n",
    "    shuffle = True\n",
    "    )\n",
    "\n",
    "#model.save_model(\"keras_basic_model.xgb\")\n",
    "\n",
    "\n",
    "# score\n",
    "\n",
    "validation_predictions = model.predict_proba(val_part.loc[:, utils.SIMPLE_FEATURE_COLUMNS].values)[:, 1]\n",
    "result = scoring.rejection90(val_part.label.values, validation_predictions, sample_weight=val_part.weight.values)\n",
    "print(result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in range(0,5):\n",
    "    \n",
    "    for j in range(0,5):\n",
    "        \n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "import multiprocessing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "'nproc' is not recognized as an internal or external command,\n",
      "operable program or batch file.\n"
     ]
    }
   ],
   "source": [
    "!nproc\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "pool = multiprocessing.Pool(processes=4)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "Error when checking input: expected dense_1_input to have shape (65,) but got array with shape (2,)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mRemoteTraceback\u001b[0m                           Traceback (most recent call last)",
      "\u001b[1;31mRemoteTraceback\u001b[0m: \n\"\"\"\nTraceback (most recent call last):\n  File \"c:\\miniconda\\envs\\py36\\lib\\multiprocessing\\pool.py\", line 119, in worker\n    result = (True, func(*args, **kwds))\n  File \"c:\\miniconda\\envs\\py36\\lib\\multiprocessing\\pool.py\", line 44, in mapstar\n    return list(map(*args))\n  File \"c:\\miniconda\\envs\\py36\\lib\\site-packages\\keras\\engine\\training.py\", line 952, in fit\n    batch_size=batch_size)\n  File \"c:\\miniconda\\envs\\py36\\lib\\site-packages\\keras\\engine\\training.py\", line 751, in _standardize_user_data\n    exception_prefix='input')\n  File \"c:\\miniconda\\envs\\py36\\lib\\site-packages\\keras\\engine\\training_utils.py\", line 138, in standardize_input_data\n    str(data_shape))\nValueError: Error when checking input: expected dense_1_input to have shape (65,) but got array with shape (2,)\n\"\"\"",
      "\nThe above exception was the direct cause of the following exception:\n",
      "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-18-f031f348a31a>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mr\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mpool\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mmap\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mmodel\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mfit\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m[\u001b[0m\u001b[0mx_train\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0my_train\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32mc:\\miniconda\\envs\\py36\\lib\\multiprocessing\\pool.py\u001b[0m in \u001b[0;36mmap\u001b[1;34m(self, func, iterable, chunksize)\u001b[0m\n\u001b[0;32m    286\u001b[0m         \u001b[1;32min\u001b[0m \u001b[0ma\u001b[0m \u001b[0mlist\u001b[0m \u001b[0mthat\u001b[0m \u001b[1;32mis\u001b[0m \u001b[0mreturned\u001b[0m\u001b[1;33m.\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    287\u001b[0m         '''\n\u001b[1;32m--> 288\u001b[1;33m         \u001b[1;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_map_async\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mfunc\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0miterable\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mmapstar\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mchunksize\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mget\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    289\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    290\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0mstarmap\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mfunc\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0miterable\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mchunksize\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\miniconda\\envs\\py36\\lib\\multiprocessing\\pool.py\u001b[0m in \u001b[0;36mget\u001b[1;34m(self, timeout)\u001b[0m\n\u001b[0;32m    668\u001b[0m             \u001b[1;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_value\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    669\u001b[0m         \u001b[1;32melse\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 670\u001b[1;33m             \u001b[1;32mraise\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_value\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    671\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    672\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0m_set\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mi\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mobj\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mValueError\u001b[0m: Error when checking input: expected dense_1_input to have shape (65,) but got array with shape (2,)"
     ]
    }
   ],
   "source": [
    "r = pool.map(model.fit, [x_train, y_train])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
